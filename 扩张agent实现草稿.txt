前提：
    未发现城市和未发现山地同表示为 = NotFound
    采用可编辑队列储存计划路径，记加入路径操作为step

考虑操作优先级 -- 数学论证

路径编码：
    六角格六边对应六进制数1位
        理解等价于二进制数3位
    得到结果一串六进制数
    压缩为十六进制表示法（或者更高
    字符串表示

路径解码
    十六进制与六进制最大公倍数为……48
    遍历
        编码末3位(48/16)解码为8位(48/6)六进制
        8位六进制解码为8个方向（逆序

有限状态机（扩张状态层）：
    状态1：搜索状态（发现空白城市
        占领空地，A*算法，step优先级-INF
        发现空白城市 to 状态2
        视野充分函数()?
            是 to 状态4
            否 to 状态1
    状态2：发现空白城市，进行占领能否判断
        占领函数(上限参数，目标价值)? -- #step过程中重复执行？先实验保守方法：step无中间插入操作
            是 to 状态3
            否 to 状态1
    状态3：占领城市
        step优先级+INF
        to 状态2
    状态4
        结束扩张状态层，进入维护状态层

视野充分函数() -- #当前最笨方法
    检查可但未抵达表[]非空?
    是 to
        return 0
    否 to
        可抵达表[]空?
        是 to
            更新可抵达表()
        否 to
            return 1

更新可抵达表() -- #再思考被调用情况
    遍历(空地+已抵达城市)=listALL，标记边缘listALL
    遍历listALL，加入可抵达表[]
    遍历可抵达表[]
        未抵达
            加入可但未抵达表

占领函数(上限参数，目标价值)
    起始节点表[] = 确定起始节点(上限参数)
    路径[][]
    路径收获表[]
    路径长度表[]
    遍历i起始节点表[]
        路径[i][]=路径选择函数(i)
        路径收获表[i]=求和函数(路径[i][])
        路径长度表[i]=求长函数(路径[i][j])
    遍历路径收获表[]
        收获>目标价值?
        是 to
            记录路径长度最短 = FinalPath
        否 to
            FinalPath = None
    return FinalPath
    

确定起始节点(上限参数)
    起始节点表[]
    未检测城市 bool = CnotF
    已检测城市低分值 int = minC
    辐射式逐层外拓循环 -- 参数、上限……
        存在城市?
        是 to
            加入城市
            CnotF=0
            更新minC
        否 to
            起始节点表[]=0?
            是 to
                加入最大兵力平原
                CnotF=1
            否 to
                CnotF=1?
                是 to
                    加入最大兵力平原
                否 to
                    当前最大兵力平原>=minC?
                    是 to
                        加入最大兵力平原
                    否 to
                        continue
                        #简化上述代码逻辑
    遍历起始节点表[]
        剔除<=minC节点
    return 起始节点表[]


路径选择函数()
    明天再写
    A*算法(逆向djstla?无边权有节点值)
    路径代价和收益加权